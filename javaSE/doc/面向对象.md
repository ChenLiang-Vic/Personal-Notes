
## 面向对象
三大特征：封装、继承、多态
### 封装
作用：提高代码的安全性和复用性。

“高内聚，低耦合”高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用

实现：使用修饰控制符private，default（不写默认是default），protected，public

1. private 只能被**本类**访问
2. default  没有修饰符修饰，被**本类以及同一个包中的其他类**访问
3. protected 被**本类、同一个包中的类、以及不同包中的子类**访问
4. public  被**该项目的所有包中的所有类**访问

需要注意的是protected在修饰方法时，如果是在不同的包中，则不能被访问，需要在子类中重写方法。

一般是将属性私有，然后提供相应的set和get方法
```java
public class Student {
    //属性
    private int id;
    private String name;
    private int age;
    
    //构造器(不写,默认会有一个无参构造器,但是只要写了有参构造器则不会有无参构造器)
    //无参构造器
    public Student() {
    }
    //有参数构造器
    public Student(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    //set和get方法
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```
### 继承
作用：容易实现类的扩展，提高代码的复用性。

注意：
- java中类只有单继承，接口有多继承
- 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法),但不见得可以直接访问(比如，父类私有的属性和方法)。
- Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类
- instanceof运算符，左边是对象，右边是类；当对象是右面类或子类所创建对象时，返回true；否则，返回false。
- 注意方法重写和重载的区别。

People类
```java
package com.company.test;

public class People {
    private String name;
    private int age;
    int num = 3;

    public People() {
    }

    public People(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "People{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```
Student类
```java
package com.company.test;

public class Student extends People{
    private int id;
    public Student() {
    }

    public Student(String name, int age, int id) {
        super(name, age);
        this.id = id;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }
}
```
测试
```java
package com.company.test;

public class Demo {
    public static void main(String[] args) {
        Student stu = new Student("陈",18,1);
        //直接访问父类非private属性
        System.out.println(stu.num);  //3
        //对于private属性使用非private的set、get方法进行操作
        System.out.println(stu.getAge());  //18

    }
}
```
另外，如果子类中定义了和父类相同的变量或者重写了父类的方法，则子类对象调用时是直接调用的子类的，如果子类没有，则再调用父类的。 对于父类对象来说，都是调用父类的。

在子类中添加了int num = 4;
父类中添加了一个say方法
```java
public void say(){
    System.out.println("人类");
}
```
子类中重写了父类的say方法
```java
@Override
public void say() {
    System.out.println("学生");
}
```

进行测试
```java
Student stu = new Student("陈",18,1);
System.out.println(stu.num);  //4
stu.say();  //学生

People p = new People("赵",20);
System.out.println(p.num);  //3
p.say();  //人类
```
### 多态
当父类的引用指向子类的对象时就称为多态

作用：允许不同的类对同一消息做出响应，即同样的请求可以根据请求对象的不同来采取不同的方法来实现

实现多态的3个必要条件：
- 必须存在继承关系。
- 子类需要重写父类的方法。
- 父类的引用指向子类的对象。（该方法称为向上转型。）

注意：
1. 成员变量访问的是父类的成员变量，无法直接调用子类中的成员变量，如果想通过对象调用子类的成员变量请直接创建子类的对象。
2. 成员方法调用中，只能访问父类中有的成员方法，如父类中的方法被子类重写则访问子类中的方法，不能访问子类特有的成员方法。
3. 静态的方法可以使用对象调用，调用时只能访问父类中的静态方法，但是静态方法是相对于类的关系，调用静态方法时用类名.方法名的方式去调用，不要使用对象来调用，静态方法不存在重写的说法。
4. 多态不能访问子类中特有的成员方法，但是也可以通过强制转化的方式让父类的引用转变成子类的引用。从而访问子类特有的成员方法，这种方法叫做向下转型，但是此时一定要注意转换关系，必须为父类引用指向子类对象的前提下才能使用。
实际开发不建议使用向下转型，需要使用子类特有的方法请创建子类对象使用。

Animal类
```java
public class Animal {
    private int a = 10;

    public Animal() {
        super();
    }

    public void eat() {
        System.out.println("动物吃东西");
    }

    public void run() {
        System.out.println("动物在地上跑");

    }
}
```
Cat类
```java 
public class Cat extends Animal {
    private int a = 20;

    public Cat() {
        super();
    }

    public void eat() {
        System.out.println("猫吃鱼");
    }

    public void sleep() {
        System.out.println("猫总是在睡觉");
    }

}
```
Dog类
```java
public class Dog extends Animal {
    public Dog() {
        super();
    }

    public void eat() {
        System.out.println("狗吃骨头");
    }

    public void sleep() {
        System.out.println("狗总是不好好睡觉");
    }

}
```
测试类
```java
public class Test {
    public static void main(String[] args) {
        Animal animal = new Cat(); // 父类引用指向子类对象
        System.out.println(animal.a); // 这里访问的是父类的成员变量
        System.out.println(new Cat().a); // 可以通过子类的对象来访问子类成员变量
        animal.eat(); // 子类中如果重写了方法则访问子类的
        animal.run(); // 子类中没有重写则访问父类的
        //animal.sleep(); 不能访问子类特有的成员方法
        Cat cat = (Cat) animal; // 强制向下转型
        cat.sleep(); // 此时可以访问子类特有的方法

        // ClassCastException异常演示
        //Animal animal2 = new Dog();
        //Cat f = (Cat) animal2; // 类型转化错误，此时animal2是Dog,不能转化为不相关的Cat类属于运行期间错误，可以通过编译.
        // 所以实际开发中不建议使用向下转型，需要使用子类特有方法时请创建子类对象或者使用子类匿名对象
    }
}

```
结果如下
```
10
20
猫吃鱼
动物在地上跑
猫总是在睡觉
```
## 抽象类
如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类和抽象方法都使用 abstract 关键字进行声明。

注意：
- 抽象方法所在类必须是抽象类，抽象类中除了抽象方法外还可以有普通变量和方法。
- 抽象方法不具体实现，子类继承后必须实现父类的抽象方法。
- 抽象类不能创建对象，可以由子类创建对象。

```java

```

## 接口


## 内部类


## 关键字
### this
### super
### static

### final
1. **修饰属性**
声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
2. **修饰方法**
声明方法不能被子类重写。

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

3. **修饰类**

声明类不允许被继承。