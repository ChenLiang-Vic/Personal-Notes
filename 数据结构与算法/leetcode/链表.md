
## 1.反转链表
[206. Reverse Linked List (Easy)](https://leetcode.com/problems/reverse-linked-list/)

迭代法：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){return head;}
        ListNode cur = head;
        ListNode prev = null;
        while(cur!=null){
            ListNode next = cur.next;
            cur.next = prev;  //注意顺序
            prev = cur;
            cur = next;
        }
        return prev;
    }
}
```
递归法：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){return head;}  //head为null或者递归结束head.next=null
        ListNode temp = head.next;
        ListNode newHead = reverseList(temp);  //此时head为倒数第二个结点，temp为倒数第一个结点
        temp.next = head;  //反转
        head.next = null;  //避免出现环
        return newHead;
    }
}
```
## 2.反转链表(m to n)
[92. Reverse Linked List II (Medium)](https://leetcode.com/problems/reverse-linked-list-ii/)

## 3.反转链表中相邻结点
[24. Swap Nodes in Pairs (Medium)](https://leetcode.com/problems/swap-nodes-in-pairs/)


## 4.判断链表是否有环
[141. Linked List Cycle(Easy)](https://leetcode.com/problems/linked-list-cycle/)


## 5.判断链表是否有环并输出环的起始位置
[142. Linked List Cycle II (Medium)](https://leetcode.com/problems/linked-list-cycle-ii/)

## 6.归并两个有序链表
[21. Merge Two Sorted Lists (Easy)](https://leetcode.com/problems/merge-two-sorted-lists/)

迭代法：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        while(l1!=null && l2!=null){
            if(l1.val < l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if(l1==null){cur.next = l2;}
        if(l2==null){cur.next = l1;}
        return dummy.next;
    }
}
```

递归法：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null){return l2;}
        if(l2 == null){return l1;}
        if(l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

## 7.从有序链表中删除重复节点
[83. Remove Duplicates from Sorted List (Easy)](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode cur = head;
        while(cur!=null && cur.next!=null){
            if(cur.val == cur.next.val){
                cur.next = cur.next.next;
            }else{
                cur = cur.next;
            }
        }
        return head;
    }
}
```
## 8.从有序链表中删除重复节点II
[82. Remove Duplicates from Sorted List II (Medium)](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)

```Java

```
## 9.删除链表的倒数第 n 个结点
[19. Remove Nth Node From End of List (Medium)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = head;
        int count = 0;
        while(cur!=null){
            cur = cur.next;
            count++;
        }
        cur = dummy;
        for(int i=0;i<count-n;i++){
            cur = cur.next;
        }
        cur.next = cur.next.next;
        return dummy.next;
    }
}
```

## 10.回文链表
[234. Palindrome Linked List (Easy)](https://leetcode.com/problems/palindrome-linked-list/description/)

```java
```

## 11.链表求和
[445. Add Two Numbers II (Medium)](https://leetcode.com/problems/add-two-numbers-ii/description/)

```java

```

## 12.找出两个链表的交点
[160. Intersection of Two Linked Lists (Easy)](https://leetcode.com/problems/intersection-of-two-linked-lists/description/)

```java

```

## 13.分隔链表
[725. Split Linked List in Parts(Medium)](https://leetcode.com/problems/split-linked-list-in-parts/description/)

```java
```

## 14.链表元素按奇偶聚集
[328. Odd Even Linked List (Medium)](https://leetcode.com/problems/odd-even-linked-list/description/)