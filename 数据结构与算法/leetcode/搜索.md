

深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此。
## 广度优先搜索(BFS)

![广度优先搜索]()

广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有结点。需要注意的是，遍历过的结点不能再次被遍历。



每一层遍历的结点都与根结点距离相同。设 di 表示第 i 个结点与根结点的距离，推导出一个结论：对于先遍历的结点 i 与后遍历的结点 j，有 di <= dj。利用这个结论，可以求解最短路径等 **最优解** 问题：第一次遍历到目的结点，其所经过的路径为最短路径。

应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个结点到另一个结点的代价都记为 1。

在程序实现 BFS 时需要考虑以下问题：

- 队列：用来存储每一轮遍历得到的结点；
- 标记：对于遍历过的结点，应该将它标记，防止重复遍历。

伪代码：

```python
def BFS(graph, start, end):

    queue = []
    queue.append([start])
    visited.add(start)

    while queue:
        node = queue.pop()
        visited.add(node)

        process(node)
        nodes = generate_related_nodes(node)
        queue.push(nodes)

    # other processing work
    ...
```

## 深度优先搜索(DFS)

![深度优先搜索]()

与广度优先搜索不同的是深度优先搜索在得到一个新结点时立即对新结点进行遍历：

从一个结点出发，使用 DFS 对一个图进行遍历时，能够遍历到的结点都是从初始结点可达的，DFS 常用来求解这种 **可达性** 问题。

在程序实现 DFS 时需要考虑以下问题：

- 栈：用栈来保存当前结点信息，当遍历新结点返回时能够继续遍历当前结点。可以使用递归栈。
- 标记：和 BFS 一样同样需要对已经遍历过的结点进行标记。

伪代码：
- 递归形式
```python

```

- 非递归形式
```python

```
## 回溯法(Backtracking)
Backtracking（回溯）属于 DFS。

- 普通 DFS 主要用在**可达性问题**，这种问题只需要执行到特点的位置然后返回即可。
- Backtracking 主要用于求解**排列组合**问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：

- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。