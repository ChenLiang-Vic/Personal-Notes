<!-- TOC -->

- [21.栈的压入、弹出序列](#21栈的压入弹出序列)
- [22.从上往下打印二叉树](#22从上往下打印二叉树)
- [23.二叉搜索树的后序遍历序列](#23二叉搜索树的后序遍历序列)
- [24.二叉树中和为某一值的路径](#24二叉树中和为某一值的路径)
- [25.复杂链表的复制](#25复杂链表的复制)
- [26.二叉搜索树与双向链表](#26二叉搜索树与双向链表)
- [27.字符串的排列](#27字符串的排列)
- [28.数组中出现次数超过一半的数字](#28数组中出现次数超过一半的数字)
- [29.最小的K个数](#29最小的k个数)
- [30.连续子数组的最大和](#30连续子数组的最大和)

<!-- /TOC -->
## 21.栈的压入、弹出序列
>思路:借助一个栈来模拟入栈和出栈的过程。先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。

举例：
入栈1,2,3,4,5

出栈4,5,3,2,1

首先1入辅助栈，此时栈顶1≠4，继续入栈2

此时栈顶2≠4，继续入栈3

此时栈顶3≠4，继续入栈4

此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3

此时栈顶3≠5，继续入栈5

此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3

….

依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。

```java

```

## 22.从上往下打印二叉树
>

```java

```

## 23.二叉搜索树的后序遍历序列
>

```java

```

## 24.二叉树中和为某一值的路径
>

```java

```

## 25.复杂链表的复制
>

```java

```

## 26.二叉搜索树与双向链表
>

```java

```

## 27.字符串的排列
>

```java

```

## 28.数组中出现次数超过一半的数字
>

```java

```

## 29.最小的K个数
>

```java

```

## 30.连续子数组的最大和
>

```java

```