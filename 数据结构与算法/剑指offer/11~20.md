<!-- TOC -->

- [11.二进制中1的个数](#11二进制中1的个数)
- [12.数值的整数次方](#12数值的整数次方)
- [13.调整数组顺序使奇数位于偶数前面](#13调整数组顺序使奇数位于偶数前面)
- [14.链表中倒数第k个结点](#14链表中倒数第k个结点)
- [15.反转链表](#15反转链表)
- [16.合并两个排序的链表](#16合并两个排序的链表)
- [17.树的子结构](#17树的子结构)
- [18.二叉树的镜像](#18二叉树的镜像)
- [19.顺时针打印矩阵](#19顺时针打印矩阵)
- [20.包含min函数的栈](#20包含min函数的栈)

<!-- /TOC -->
## 11.二进制中1的个数
>位运算
链接：https://www.nowcoder.com/questionTerminal/8ee967e43c2c4ec193b040ea7fbb10b8?answerType=1&f=discussion
如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。
举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

```java
public class Solution {
    public int NumberOf1(int n) {
        int count=0;
        while(n!=0){
            count++;
            n=n&(n-1);
        }
        return count;
    }
}
```

## 12.数值的整数次方
>

```java

```

## 13.调整数组顺序使奇数位于偶数前面
>1.使用额外的两个数组或队列分别存放偶数和奇数再合并 时间复杂度O(n) 空间复杂度O(n)
2.不开辟额外空间，参考冒泡排序思想进行交换

2.直接交换
```java

```

## 14.链表中倒数第k个结点
>1.先找链表中总结点数len，然后找到len-k个节点的位置
2.快慢指针法  快指针先走k个，然后快慢指针一起走，最后慢指针指向的即是倒数第k个节点。

快慢指针法
```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null || k==0) return null;
        ListNode slow = head;
        ListNode fast = head;
        for(int i=0;i<k;i++){
            if(fast == null) return null;   //可能会出现k比链表长度大的情况
            fast = fast.next;
        }
        while(fast!=null){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

## 15.反转链表

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;
        while(cur!= null){
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}
```

## 16.合并两个排序的链表
>1.递归法
2.非递归法


递归
```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null) return list2;
        if(list2 == null) return list1;
        if(list1.val <= list2.val){
            list1.next = Merge(list1.next,list2);
            return list1;
        }else{
            list2.next = Merge(list1,list2.next);
            return list2;
        }
    }
}
```
非递归
```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null) return list2;
        if(list2 == null) return list1;
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        while(list1!=null && list2!=null){
            if(list1.val<list2.val){
                cur.next = list1;
                list1 = list1.next;
            }else{
                cur.next = list2;
                list2 = list2.next;
            }
            cur = cur.next;
        }
        if(list1 == null) cur.next = list2;
        if(list2 == null) cur.next = list1;
        return dummy.next;
    }
}
```

## 17.树的子结构
>递归求解

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1==null || root2==null) return false;
        return judgeHasSubtree(root1, root2) ||
               judgeHasSubtree(root1.left, root2) ||
               judgeHasSubtree(root1.right, root2);
    }
    private boolean judgeHasSubtree(TreeNode root1,TreeNode root2){
        if(root2==null) return true;
        if(root1==null) return false;
        if(root1.val == root2.val){
            return judgeHasSubtree(root1.left,root2.left) && judgeHasSubtree(root1.right,root2.right);
        }
        return false;
    }
}
```

## 18.二叉树的镜像
>很明显使用递归方式解决

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null) return;
        TreeNode temp = null;
        temp = root.left;
        root.left=root.right;
        root.right = temp;
        Mirror(root.left);
        Mirror(root.right);
    }
}
```

## 19.顺时针打印矩阵
>

```java

```

## 20.包含min函数的栈
>使用了两个栈，一个栈用来存数据，另一个栈用来存储当前栈中的数据的最小值，其中若后面push的数据比当前最小值大，最小值栈仍然push当前最小值。

```java
import java.util.Stack;

public class Solution {

    private Stack<Integer> dataStack = new Stack<>();
    private Stack<Integer> minStack = new Stack<>();
    int min = Integer.MAX_VALUE;
    
    public void push(int node) {
        dataStack.push(node);
        if(node<min) min=node;
        minStack.push(min);
    }
    
    public void pop() {
        dataStack.pop();
        minStack.pop();
        //可能pop出去最小值所以要更新min值
        min = minStack.isEmpty()? Integer.MAX_VALUE : minStack.peek();
    }
    
    public int top() {
        return dataStack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```