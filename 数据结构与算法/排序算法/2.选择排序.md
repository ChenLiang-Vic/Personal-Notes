# 选择排序法  
## 基本思想  
从第一个元素开始，寻找整个数组，找到最小元素后再与第一个元素交换位置，然后再从第二个元素开始，继续寻找最小的元素与第二个元素交换位置，依次类推  
![排序算法动图演示](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)  
## 基本选择排序  
~~~java
public void selectSort(int[] datas){
        int minindex = 0;
        for (int i = 0; i < datas.length-1; i++) {
            minindex = i;
            for (int j = i+1; j < datas.length; j++) {
                if(datas[j]<datas[minindex])
                    minindex = j;
            }
            if(datas[minindex]<datas[i]){
                int temp;
                temp = datas[i];
                datas[i] = datas[minindex];
                datas[minindex] = temp;
            }
            System.out.println("第"+(i+1)+"轮排序后为："+Arrays.toString(datas));
        }
    }
~~~
~~~
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后为：[1, 7, 2, 5, 4, 3, 9, 10, 8, 6]
第2轮排序后为：[1, 2, 7, 5, 4, 3, 9, 10, 8, 6]
第3轮排序后为：[1, 2, 3, 5, 4, 7, 9, 10, 8, 6]
第4轮排序后为：[1, 2, 3, 4, 5, 7, 9, 10, 8, 6]
第5轮排序后为：[1, 2, 3, 4, 5, 7, 9, 10, 8, 6]
第6轮排序后为：[1, 2, 3, 4, 5, 6, 9, 10, 8, 7]
第7轮排序后为：[1, 2, 3, 4, 5, 6, 7, 10, 8, 9]
第8轮排序后为：[1, 2, 3, 4, 5, 6, 7, 8, 10, 9]
第9轮排序后为：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~  
## 算法分析
### 复杂度分析  
#### 时间复杂度  
因为无论怎样，选择排序都会进行1+2+......+（n-1）次比较操作，时间复杂度为O(n<sup>2</sup>) 
- 最好情况：数组正序，交换操作为0次
- 最坏情况：数组倒序，交换操作为n-1次
- 平均情况：**时间复杂度为O(n<sup>2</sup>)**  
可以看到和冒泡排序法相比，交换次数减少了很多，所以n值较小时，选择排序比冒泡排序快。
#### 空间复杂度  
选择排序是在原输入数组上进行交换赋值操作的（称“**就地排序**”），所需开辟的辅助空间跟输入数组规模无关，所以**空间复杂度为O(1)**
### 稳定性分析  
在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。  举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以**选择排序是不稳定排序**。