## 选择排序法  
### 基本思想  
从第一个元素开始，寻找整个数组，找到最小元素后再与第一个元素交换位置，然后再从第二个元素开始，继续寻找最小的元素与第二个元素交换位置，依次类推  
![排序算法动图演示](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)  
### 基本选择排序  
~~~java
public void selectSort(int[] datas){
        int minindex = 0;
        for (int i = 0; i < datas.length-1; i++) {
            minindex = i;
            for (int j = i+1; j < datas.length; j++) {
                if(datas[j]<datas[minindex])
                    minindex = j;
            }
            if(datas[minindex]<datas[i]){
                int temp;
                temp = datas[i];
                datas[i] = datas[minindex];
                datas[minindex] = temp;
            }
            System.out.println("第"+(i+1)+"轮排序后为："+Arrays.toString(datas));
        }
    }
~~~
~~~
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后为：[1, 7, 2, 5, 4, 3, 9, 10, 8, 6]
第2轮排序后为：[1, 2, 7, 5, 4, 3, 9, 10, 8, 6]
第3轮排序后为：[1, 2, 3, 5, 4, 7, 9, 10, 8, 6]
第4轮排序后为：[1, 2, 3, 4, 5, 7, 9, 10, 8, 6]
第5轮排序后为：[1, 2, 3, 4, 5, 7, 9, 10, 8, 6]
第6轮排序后为：[1, 2, 3, 4, 5, 6, 9, 10, 8, 7]
第7轮排序后为：[1, 2, 3, 4, 5, 6, 7, 10, 8, 9]
第8轮排序后为：[1, 2, 3, 4, 5, 6, 7, 8, 10, 9]
第9轮排序后为：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~  
算法分析：  
选择排序与冒泡排序一样，需要进行n*(n-1)/2次比较，但是只需要N次交换，当N很大时，交换次数的时间影响力更大，所以**选择排序的时间复杂度为O(n<sup>2</sup>)**。
虽然选择排序与冒泡排序在时间复杂度属于同一量级，但是毫无疑问选择排序的效率更高，因为它的交换操作次数更少，而且在交换操作比比较操作的时间级大得多时，选择排序的速度是相当快的。  

另外在稳定性方面，由于是进行比较后直接进交换，比如5 8 5 2 9，第一遍之后，2会与5交换，那么原序列中两个5的顺序就被破坏了。所以**选择排序是不稳定排序**