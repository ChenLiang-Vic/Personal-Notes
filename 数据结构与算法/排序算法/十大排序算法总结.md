## 排序算法分类
![排序算法分类](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/img/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png)

## 排序算法时间复杂度
![排序算法时间复杂度](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/img/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.png)

## 总结
从上面的图中我们可以把非线性时间比较排序分为两类：
简单算法：直接插入、冒泡、简单选择
改进算法：希尔排序、快速、堆、  归并

1. 从平均情况看，显然后3种改进算法要胜过希尔排序，并远胜过前3中简单算法。

2. 从最好情况看，反而冒泡排序和直接插入排序效果最好，也就是说，如果待排序列总是基本有序，反而可以直接使用冒泡或者直接插入排序。

3. 从最坏情况看，堆排序与归并排序又好于快速排序和其他简单排序，所以对于待排序列基本倒叙则可以考虑这两种方法。

4. 从空间复杂度上来所，归并排序和快速排序都有相应的空间要求，反而堆排序确是O(1)，所以对于只有少量内存进行排序时可以考虑使用堆排序。并且对于海量数据的排序可以通过建立小顶堆或者大顶堆的方式进行排序。


另外对于线性时间非比较类的3种排序方法：
计数排序更适用于在已知序列中的元素0-k之间，且要求排序的复杂度在线性效率上的情况。

桶排序可应用于数据量分布比较均匀，或比较侧重区间数量时使用。

基数排序最适用于基数很大但关键字较小的序列