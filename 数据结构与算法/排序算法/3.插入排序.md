## 插入排序法  
### 基本思想  
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。  

![插入排序动图演示](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)  

### 基本插入排序    
~~~java
public void insertSort(int[] datas){
        int current;  
        for (int i = 0; i < datas.length-1; i++) {
            current = datas[i + 1];  //存储当前待插入元素值
            int preIndex = i;  //存储有序元素序列最后一位元素值
            while (preIndex >= 0 && current < datas[preIndex]) {
                datas[preIndex + 1] = datas[preIndex];
                preIndex--;
            }
            datas[preIndex + 1] = current;
            System.out.println("第" + (i + 1) + "轮排序后为：" + Arrays.toString(datas));
        }
    }
~~~  
运算结果：
~~~
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后为：[1, 7, 2, 5, 4, 3, 9, 10, 8, 6]
第2轮排序后为：[1, 2, 7, 5, 4, 3, 9, 10, 8, 6]
第3轮排序后为：[1, 2, 5, 7, 4, 3, 9, 10, 8, 6]
第4轮排序后为：[1, 2, 4, 5, 7, 3, 9, 10, 8, 6]
第5轮排序后为：[1, 2, 3, 4, 5, 7, 9, 10, 8, 6]
第6轮排序后为：[1, 2, 3, 4, 5, 7, 9, 10, 8, 6]
第7轮排序后为：[1, 2, 3, 4, 5, 7, 9, 10, 8, 6]
第8轮排序后为：[1, 2, 3, 4, 5, 7, 8, 9, 10, 6]
第9轮排序后为：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~  

### 算法分析  
与冒泡排序、选择排序一样，**插入排序的时间复杂度仍然为O(n<sup>2</sup>)** 。这三者被称为简单排序或者基本排序。如果待排序数组基本有序时，插入排序的效率会更高。  

因为在插入过程中，如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以**插入排序是稳定排序**  

---
### 排序算法改进  
从上面可以看到，在每次插入时都需要对前面已经排好序的数组序列进行逐个扫描对比，当数据量比较大时，是一个比较浪费时间的过程。  

解决方法：采用**二分查找法**直接查找插入的位置，这种方法也称为**二分插入排序**  
~~~java

~~~
算法分析：  
