# 冒泡排序法  
## 基本思想  
每一轮将相邻两个数进行比较，如果发现两个数的排序与排序的要求相反时就将他们交换，每次遍历可以确定一个最小的元素"浮"到数组顶端  

## 算法描述

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤1~3，直到排序完成。

![冒泡排序动图演示](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/img/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)
## 基本冒泡排序  
```java
public void bubbleSort(int[] data){
        int temp;
        for (int i = 0; i < data.length-1 ; i++) {
            for(int j=1;j<data.length-i;j++){
                if(data[j-1]>data[j]){
                    temp = data[j-1];
                    data[j-1] = data[j];
                    data[j] = temp;
                }
            }
            System.out.println("第"+(i+1)+"轮排序后："+ Arrays.toString(data));
        }
    }
```
运行结果：  
```
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后：[1, 2, 5, 4, 3, 7, 9, 8, 6, 10]
第2轮排序后：[1, 2, 4, 3, 5, 7, 8, 6, 9, 10]
第3轮排序后：[1, 2, 3, 4, 5, 7, 6, 8, 9, 10]
第4轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第5轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第6轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第7轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第8轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第9轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
## 算法分析
### 复杂度分析  
#### 时间复杂度  
- 最好情况：数组正序，1轮就能排好序，交换0次，时间复杂度为O(n)
- 最坏情况：数组倒序，比较1+2+......+(n-1)=n(n-1)/2次,交换n(n-1)/2次，时间复杂度为O(n<sup>2</sup>)
- 平均情况：**时间复杂度为O(n<sup>2</sup>)**  。
#### 空间复杂度  
冒泡排序是在原输入数组上进行交换赋值操作的（称“**就地排序**”），所需开辟的辅助空间跟输入数组规模无关，所以**空间复杂度为O(1)**
### 稳定性分析  
因为只有在前一位比后一位大时才交换(体现在data[j-1]>data[j]),相等时不进行交换，所以**冒泡排序是稳定排序**。  

---

## 冒泡排序改进  
从上面的例子中可以看出，在进行到第4轮排序后，数组已经完全拍好序，所以后面几轮排序为冗余排序。 

解决方法：加入标志位exchange，如果没进行交换，则结束循环。
```java
public void BubbleSort(int[] datas){
        boolean exchange;
        for (int i = 0; i < datas.length-1; i++) {
            exchange = false;  //设置标志位
            for (int j = datas.length-1; j > i; j--) { 
                if(datas[j]<datas[j-1]){
                    int temp;
                    temp = datas[j-1];
                    datas[j-1] = datas[j];
                    datas[j] = temp;
                    exchange = true;
                }
            }

            if (!exchange) break;  //如果没有发生交换则直接结束
            System.out.println("第"+(i+1)+"轮排序后："+ Arrays.toString(datas)); 
            
        }
    }
```
```
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后：[1, 2, 5, 4, 3, 7, 9, 8, 6, 10]
第2轮排序后：[1, 2, 4, 3, 5, 7, 8, 6, 9, 10]
第3轮排序后：[1, 2, 3, 4, 5, 7, 6, 8, 9, 10]
第4轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
``` 
## 算法分析
### 复杂度分析  
可以看到改进后比较轮数减少，但是总的来说时间复杂度仍然是O(n<sup>2</sup>) 
