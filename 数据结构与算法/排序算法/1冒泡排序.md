# 冒泡排序法  
## 基本思想  
每一轮将相邻两个数进行比较，如果发现两个数的排序与排序的要求相反时就将他们交换，每次遍历可以确定一个最小的元素"浮"到数组顶端  
![冒泡排序动图演示](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/img/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)
## 基本冒泡排序  
~~~java
public void BubbleSort(int[] datas){
        for (int i = 0; i < datas.length-1; i++) {  //需要进行datas.length-1轮比较
            for (int j = datas.length-1; j > i; j--) {  //从后往前进行比较，每次完成后最小的数在最前面
                if(datas[j]<datas[j-1]){  //后一位比前一位小则交换顺序
                    int temp;
                    temp = datas[j-1];
                    datas[j-1] = datas[j];
                    datas[j] = temp;
                }
            }
            System.out.println("第"+(i+1)+"轮排序后："+ Arrays.toString(datas));  //为了方便观察，打印每次排序后的数组
        }
    }
~~~
运行结果：  
~~~
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后：[1, 7, 2, 3, 5, 4, 6, 9, 10, 8]
第2轮排序后：[1, 2, 7, 3, 4, 5, 6, 8, 9, 10]
第3轮排序后：[1, 2, 3, 7, 4, 5, 6, 8, 9, 10]
第4轮排序后：[1, 2, 3, 4, 7, 5, 6, 8, 9, 10]
第5轮排序后：[1, 2, 3, 4, 5, 7, 6, 8, 9, 10]
第6轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第7轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第8轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第9轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~
## 算法分析
### 复杂度分析  
#### 时间复杂度  
- 最好情况：数组正序，1轮就能排好序，交换0次，时间复杂度为O(n)
- 最坏情况：数组倒序，比较1+2+......+(n-1)=n(n-1)/2次,交换n(n-1)/2次，时间复杂度为O(n<sup>2</sup>)
- 平均情况：**时间复杂度为O(n<sup>2</sup>)**  。
#### 空间复杂度  
冒泡排序是在原输入数组上进行交换赋值操作的（称“**就地排序**”），所需开辟的辅助空间跟输入数组规模无关，所以**空间复杂度为O(1)**
### 稳定性分析  
因为只有在后一位比前一位小时才交换(体现在datas[j]<datas[j-1]),相等时不进行交换，所以**冒泡排序是稳定排序**。  

---

## 冒泡排序改进  
从上面的例子中可以看出，在进行到第6轮排序后，数组已经完全拍好序，所以后面几轮排序为冗余排序。 

解决方法：加入标志位exchange，如果没进行交换，则结束循环。
~~~java
public void BubbleSort(int[] datas){
        boolean exchange;
        for (int i = 0; i < datas.length-1; i++) {
            exchange = false;  //设置标志位
            for (int j = datas.length-1; j > i; j--) { 
                if(datas[j]<datas[j-1]){
                    int temp;
                    temp = datas[j-1];
                    datas[j-1] = datas[j];
                    datas[j] = temp;
                    exchange = true;
                }
            }
            System.out.println("第"+(i+1)+"轮排序后："+ Arrays.toString(datas)); 
            if (!exchange) break;  //如果没有发生交换则直接结束
        }
    }
~~~
~~~
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后：[1, 7, 2, 3, 5, 4, 6, 9, 10, 8]
第2轮排序后：[1, 2, 7, 3, 4, 5, 6, 8, 9, 10]
第3轮排序后：[1, 2, 3, 7, 4, 5, 6, 8, 9, 10]
第4轮排序后：[1, 2, 3, 4, 7, 5, 6, 8, 9, 10]
第5轮排序后：[1, 2, 3, 4, 5, 7, 6, 8, 9, 10]
第6轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第7轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~  
## 算法分析
### 复杂度分析  
可以看到改进后比较轮数减少，但是总的来说时间复杂度仍然是O(n<sup>2</sup>) 
