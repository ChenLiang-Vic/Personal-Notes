## 冒泡排序法  
### 基本思想  
每一轮将相邻两个数进行比较，如果发现两个数的排序与排序的要求相反时就将他们交换，每次遍历可以确定一个最小的元素"浮"到数组顶端  

### 基本冒泡排序  
~~~java
public void BubbleSort(int[] datas){
        for (int i = 0; i < datas.length-1; i++) {  //需要进行datas.length-1轮比较
            for (int j = datas.length-1; j > i; j--) {  //从后往前进行比较，每次完成后最小的数在最前面
                if(datas[j]<datas[j-1]){  //后一位比前一位小则交换顺序
                    int temp;
                    temp = datas[j-1];
                    datas[j-1] = datas[j];
                    datas[j] = temp;
                }
            }
            System.out.println("第"+(i+1)+"轮排序后："+ Arrays.toString(datas));  //为了方便观察，打印每次排序后的数组
        }
    }
~~~
运行结果：  
~~~
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后：[1, 7, 2, 3, 5, 4, 6, 9, 10, 8]
第2轮排序后：[1, 2, 7, 3, 4, 5, 6, 8, 9, 10]
第3轮排序后：[1, 2, 3, 7, 4, 5, 6, 8, 9, 10]
第4轮排序后：[1, 2, 3, 4, 7, 5, 6, 8, 9, 10]
第5轮排序后：[1, 2, 3, 4, 5, 7, 6, 8, 9, 10]
第6轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第7轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第8轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第9轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~
算法分析：  
因为第一轮循环时需要进行n-1次比较，第二轮循环时进行n-2次比较，所以n个元素时则一共需要的比较次数为：(n-1)+ (n-2)+ (n-3)+ ...1=n*(n-1)/2所以**冒泡排序时间复杂度为O(n<sup>2</sup>)** 

由于每次排序只会在后面元素比前面元素小时才进行交换所以是**冒泡排序是稳定排序**  

---

### 冒泡排序改进  
从上面的例子中可以看出，在进行到第6轮排序后，数组已经完全拍好序，所以后面几轮排序为冗余排序。 

解决方法：加入标志位exchange，如果没进行交换，则结束循环。
~~~java
public void BubbleSort(int[] datas){
        boolean exchange;
        for (int i = 0; i < datas.length-1; i++) {
            exchange = false;  //设置标志位
            for (int j = datas.length-1; j > i; j--) { 
                if(datas[j]<datas[j-1]){
                    int temp;
                    temp = datas[j-1];
                    datas[j-1] = datas[j];
                    datas[j] = temp;
                    exchange = true;
                }
            }
            System.out.println("第"+(i+1)+"轮排序后："+ Arrays.toString(datas)); 
            if (!exchange) break;  //如果没有发生交换则直接结束
        }
    }
~~~
~~~
未排序时：[7, 1, 2, 5, 4, 3, 9, 10, 8, 6]
第1轮排序后：[1, 7, 2, 3, 5, 4, 6, 9, 10, 8]
第2轮排序后：[1, 2, 7, 3, 4, 5, 6, 8, 9, 10]
第3轮排序后：[1, 2, 3, 7, 4, 5, 6, 8, 9, 10]
第4轮排序后：[1, 2, 3, 4, 7, 5, 6, 8, 9, 10]
第5轮排序后：[1, 2, 3, 4, 5, 7, 6, 8, 9, 10]
第6轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
第7轮排序后：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~  
算法分析：  
可以看到，与之前相比，减少了2轮排序，在第6轮排序完成后（第7轮为检验）就停止了排序。  
