## 二叉排序树(二叉查找树)
二叉排序树(Binary Sort Tree),又称为二叉查找树。它通常是一颗空树，或者是有下列性质的二叉树：
- **若它的左子树不空，则左子树上的所有结点的值均小于它的根结点的值**
- **若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值**
- **它的左、右子树也分别为二叉排序树**

二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。

```java

```

**复杂度分析**
和二分查找一样，插入和查找的**时间复杂度O(logn)**，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。

## 平衡二叉树(AVL树)

**AVL树是带有平衡条件的二叉查找树，要求每一个结点的左子树和右子树的高度差至多等于1**。一般是用平衡因子差值(二叉树上结点的左子树减去右子树深度的值)判断是否平衡并通过旋转来实现平衡。

不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道**AVL树适合用于插入与删除次数比较少，但查找多的情况**。

注意平衡二叉树首先要是二叉排序树，即符合二叉排序树的定义，然后才是每个结点的左子树和右子树的高度差至多等于1。

## 红黑树
红黑树是一种二叉查找树，但在每个结点增加一个存储位表示结点的颜色，可以是红或黑（非红即黑）。**通过对任何一条从根到叶子的路径上各个结点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍**，因此，**红黑树是一种弱平衡二叉树**（由于是弱平衡，可以看到，在相同的结点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以**对于搜索，插入，删除操作较多的情况下，应该使用红黑树**。

红黑树的性质:
- 每个结点非红即黑.
- 根结点是黑的。
- 每个叶结点(叶结点即树尾端NULL指针或NULL结点)都是黑的.
- 如果一个结点是红的,那么它的两儿子都是黑的.
- 对于任意结点而言,其到叶子点树NULL指针的每条路径都包含相同数目的黑结点.

## 2-3树
上面学习的BST、AVL、RBT都是典型的二叉查找树结构，其查找的时间复杂度与树高相关，都是在内存中进行的。那么降低树高自然对查找效率是有所帮助的。

另外还有一个比较实际的问题：就是大量数据存储中，实现查询这样一个实际背景下，平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。那么如何减少树的深度（当然不能减少查询数据量），一个基本的想法就是：

1. 每个结点存储多个元素（但元素数量不能无限多，否则查找就退化成了结点内部的线性查找了）。

2. 摒弃二叉树结构，采用多叉树（由于结点内元素数量不能无限多，自然子树的数量也就不会无限多了）。

**多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素**。由于是查找树，所有元素间存在某种特定的排序关系。2-3树、2-3-4树、B树、B+树都是特殊形式的多路查找树。

**2-3树的性质**：
- 每个节点都具有2个孩子（称之为2节点）或者3个孩子（称之为3节点）。
- 一个2节点包含一个元素和两个孩子（或没有孩子）
- 一个3节点包含两个元素和三个孩子（或没有孩子）
- 所有叶子结点都在同一层次

![2-3树]()

了解了2-3树，2-3-4树就容易理解了，它其实是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子(或没有孩子)。四个孩子还是和3结点一样，左子树包含小于最小元素的元素；第二子树在最小元素和第二元素之间，第三子树在第二元素和最大元素之间，右子树包含大于最大元素的元素。

## B树

## B+树
