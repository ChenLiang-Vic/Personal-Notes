## 传输层
运输层向它上面应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最底层。

两个主机进行通信实际上就是**两个主机中的应用进程互相通信**。应用进程之间的通信又称为**端到端的通信**。
![传输层]()

传输层有两种不同的协议：**用户数据报协议UDP**和**传输控制协议TCP**

学习这两个重要协议之前，先简单了解下端口的概念。
#### 端口
为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法**对 TCP/IP 体系的应用进程进行标志**。解决这个问题的方法就是在运输层使用**协议端口号**(protocol port number)，或通常简称为**端口**(port)，端口用一个 16 位端口号进行标志。

**端口号只具有本地意义**，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。

端口号分为两类：

1. 服务端使用的端口号
服务器端使用的端口又分为两类：
    - 熟知端口（well-known port number），数值一般为0~1023。管理机构IANA把这些端口指派给TCP/IP最重要的一些应用程序，让所有用户都知道。
![熟知端口]()
    - 登记端口，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。
2. 客户端使用的端口号
数值为49152~65535，留给客户进程选择暂时使用，仅在客户进程运行时彩动态选择，因此又叫**短暂端口号**。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。

## 用户数据报协议UDP
UDP 只在IP的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。
### UDP特点
- **无连接**   (即发送数据之前不需要建立连接)
- **不可靠**   (UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制)
- **面向报文** (对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)
- **支持一对一、一对多、多对一、多对多的交互通信**

### UDP首部
![UDP首部]()
首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。
## 控制连接协议TCP
TCP除了基本的数据交付和差错检查外，还提供了**可靠数据传输**和**拥塞控制服务**
### TCP特点
- **面向连接**
- **提供可靠交付**
- **面向字节流**  （把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）
- **只能是点对点的（一对一）**
### TCP首部
![TCP首部]()
- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据,用于进行流量控制。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。  
### TCP连接控制
运输连接就有三个阶段，即：**连接建立**、**数据传送**和**连接释放**。运输连接的管理就是使运输连接的建立和释放都能正常地进行。

TCP 连接的建立都是采用**客户服务器**方式。主动发起连接建立的应用进程叫做客户(client)。被动等待连接建立的应用进程叫做服务器(server)。

#### TCP连接建立(三次握手)
![TDP三次握手]()
1. 上图中，B的服务器进程先创建**传输控制块TCB**，准备接受客户进程的连接请求。然后服务器进程就处于**LISTEN**（监听)状态，等待客户的连接请求。

2. A的TCP客户进程也是首先创建**传输控制块TCB**，然后向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入**SYN-SENT**（同步已发送）状态。

3. B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK为都置1，确认好ack=x+1，同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但同样要消耗一个序号。这时TCP服务器进程进入**SYN-RCVD**（同步收到）状态。

4. TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1.确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号。这时，TCP连接已建立，A进入**ESTABLISHEN**（已建立连接）状态。

当B收到A的确认后，也进入**ESTABLISHEN**状态。

上面的过程称为**三次握手**。

#### TCP的连接释放（四次挥手）
![TCP四次握手]()  
1. 数据传输结束后，A和B处于**ESTABLISHEN**状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN置1，其序号seq=u，等于前面已经传送过的数据的最后一个字节的加1.这时A进入**FIN-WAIT-1**（终止等待1）状态，等待B的确认。

2. B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v。等于B前面已经传送过的数据的最后一个字节的序号加1。然后B进入**CLOSE-WAIT**（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态。即A已经没有数据要发送了，但B若发送数据，A仍要接受。
 A收到来自B的确认后，就进入**FIN-WAIT-2**（终止等待2）状态，等待B发出的连接释放报文段。

3. 若B已经没有要向A发送的数据，其应用进程就通知TCP释放链接。这时B发出的报文段必须使FIN=1。现假定B的序号为w（在半关闭状态B可能由发送了一些数据）。B还必须重复上次已经发送过的确认号ack=u+1。这时B就进入**LAST-ACK**（最后确认）状态，等待A的确认。

4. A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1。然后进入到**TIME-WAIT**（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器设置的时间2MSL后，A才进入到**CLOSED**状态。时间MSL叫做最长报文段寿命（Maximum Segment Lifetime）。
#### TCP有限状态机
TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。  

![TCP有限状态机]()

图中有三种不同的箭头：
粗实线箭头表示对客户进程的正常变迁。
粗虚线箭头表示对服务器进程的正常变迁。
另一种细线箭头表示异常变迁。

### TCP可靠数据传输

### TCP流量控制
一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后，它就将数据放入接收缓存。相关联的应用进程就会从该缓存中读取数据。如果某应用程序读取数据时相对缓慢就，或者说由于其他任务过段时间再来读取，而发送方发送的太多、太快，就会使该连接的接收缓存溢出。

TCP通过让发送方维护一个称为**接收窗口**的变量来进行流量控制。实际上，窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的**窗口字段**告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

假设主机A通过一条TCP连接向主机B发送一个大文件，主机B为该连接分配了一个接收缓存，并且主机B不时的从缓存中读取数据，定义以下变量：  

- RcvBuffer ： B的接收缓存大小
- LastByteRead： B的应用程序从缓存中读出的数据流的最后一个字节编号
- LastByteRcvd：从网络中到达并且已经放入B接收缓存中的数据流的最后一个字节的编号。  
由于TCP不允许内存溢出，所以：LastByteRcvd-LastByteRead<=RcvBuffer
接收窗口用rwnd表示则缓存可用空间：rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]  
主机B将rwnd的值放入发送给A的报文段中的窗口字段，通知A还有多少可用空间。
对于A需要跟踪两个变量：LastByteSent和LastByteAcked，这两个变量的意义很明显，而LastByteSent-LastByteAcked就是主机A发送到连接中但未被确认的数据量。只需要将未确认的数据量控制在rwnd以内，就可以保证不会使B的接收缓存溢出。
即：**LastByteSent-LastByteAcked<=rwnd**
### TCP拥塞控制
如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。
这一点和流量控制很像，但是出发点不同。**拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。而流量控制不同，流量控制指对点对点通信量的控制**

拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。

发送方需要维护一个叫做**拥塞窗口**（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。
![TCP拥塞控制]()
为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。
![拥塞控制窗口]()
