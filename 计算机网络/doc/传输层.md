[TOC]
## 传输层
运输层向它上面应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最底层。

两个主机进行通信实际上就是**两个主机中的应用进程互相通信**。应用进程之间的通信又称为**端到端的通信**。
![传输层](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/%E4%BC%A0%E8%BE%93%E5%B1%82.png)

传输层有两种不同的协议：**用户数据报协议UDP**和**传输控制协议TCP**

学习这两个重要协议之前，先简单了解下端口的概念。
#### 端口
为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法**对 TCP/IP 体系的应用进程进行标志**。解决这个问题的方法就是在运输层使用**协议端口号**(protocol port number)，或通常简称为**端口**(port)，端口用一个 16 位端口号进行标志。

**端口号只具有本地意义**，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。

端口号分为两类：

1. 服务端使用的端口号
服务器端使用的端口又分为两类：
    - 熟知端口（well-known port number），数值一般为0~1023。管理机构IANA把这些端口指派给TCP/IP最重要的一些应用程序，让所有用户都知道。
![熟知端口](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/%E7%86%9F%E7%9F%A5%E7%AB%AF%E5%8F%A3.png)
    - 登记端口，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。
2. 客户端使用的端口号
数值为49152~65535，留给客户进程选择暂时使用，仅在客户进程运行时彩动态选择，因此又叫**短暂端口号**。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。

## 用户数据报协议UDP
UDP 只在IP的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。
### UDP特点
- **无连接**   (即发送数据之前不需要建立连接)
- **不可靠**   (UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制)
- **面向报文** (对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)
- **支持一对一、一对多、多对一、多对多的交互通信**

### UDP首部
![UDP首部](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/UDP%E9%A6%96%E9%83%A8.png)
首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。
## 控制连接协议TCP
TCP除了基本的数据交付和差错检查外，还提供了**可靠数据传输**和**拥塞控制服务**
### TCP特点
- **面向连接**
- **提供可靠交付**
- **面向字节流**  （把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）
- **只能是点对点的（一对一）**
### TCP首部
![TCP首部](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/TCP%E9%A6%96%E9%83%A8.png)
- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据,用于进行流量控制。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 

## TCP可靠数据传输
### TCP连接控制
运输连接就有三个阶段，即：**连接建立**、**数据传送**和**连接释放**。运输连接的管理就是使运输连接的建立和释放都能正常地进行。

TCP 连接的建立都是采用**客户服务器**方式。主动发起连接建立的应用进程叫做客户(client)。被动等待连接建立的应用进程叫做服务器(server)。

#### TCP连接建立(三次握手)
![TDP三次握手](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)
1. 上图中，B的服务器进程先创建**传输控制块TCB**，准备接受客户进程的连接请求。然后服务器进程就处于**LISTEN**（监听)状态，等待客户的连接请求。

2. A的TCP客户进程也是首先创建**传输控制块TCB**，然后向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入**SYN-SENT**（同步已发送）状态。

3. B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK为都置1，确认好ack=x+1，同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但同样要消耗一个序号。这时TCP服务器进程进入**SYN-RCVD**（同步收到）状态。

4. TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1.确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号。这时，TCP连接已建立，A进入**ESTABLISHEN**（已建立连接）状态。

当B收到A的确认后，也进入**ESTABLISHEN**状态。

上面的过程称为**三次握手**。

#### TCP的连接释放（四次挥手）
![TCP四次握手](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/TCP%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png)  
1. 数据传输结束后，A和B处于**ESTABLISHEN**状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN置1，其序号seq=u，等于前面已经传送过的数据的最后一个字节的加1.这时A进入**FIN-WAIT-1**（终止等待1）状态，等待B的确认。

2. B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v。等于B前面已经传送过的数据的最后一个字节的序号加1。然后B进入**CLOSE-WAIT**（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态。即A已经没有数据要发送了，但B若发送数据，A仍要接受。
 A收到来自B的确认后，就进入**FIN-WAIT-2**（终止等待2）状态，等待B发出的连接释放报文段。

3. 若B已经没有要向A发送的数据，其应用进程就通知TCP释放链接。这时B发出的报文段必须使FIN=1。现假定B的序号为w（在半关闭状态B可能由发送了一些数据）。B还必须重复上次已经发送过的确认号ack=u+1。这时B就进入**LAST-ACK**（最后确认）状态，等待A的确认。

4. A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1。然后进入到**TIME-WAIT**（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器设置的时间2MSL后，A才进入到**CLOSED**状态。时间MSL叫做最长报文段寿命（Maximum Segment Lifetime）。
#### TCP有限状态机
TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。  

![TCP有限状态机](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/TCP%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png)

图中有三种不同的箭头：
粗实线箭头表示对客户进程的正常变迁。
粗虚线箭头表示对服务器进程的正常变迁。
另一种细线箭头表示异常变迁。

#### TCP连接常见问题
1. **为什么需要 TIME_WAIT 状态？**

假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入 TIME_WAIT 状态，因为client可能面 临重发最终ACK的情形。

2. **为什么 TIME_WAIT 状态需要保持 2MSL 这么长的时间？**

如果 TIME_WAIT 状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。

3. **TCP为什么不是两次连接，而是三次握手？**

如果A与B两个进程通信，如果仅是两次连接。可能出现的一种情况就是：A发送完请报文以后，由于网络情况不好，出现了网络拥塞，即B延时很长时间后收到报文，即此时A将此报文认定为失效的报文。B收到报文后，会向A发起连接。此时两次握手完毕，B会认为已经建立了连接可以通信，B会一直等到A发送的连接请求，而A对失效的报文回复自然不会处理。依次会陷入B忙等的僵局，造成资源的浪费。

4. **为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？**

因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

5. **为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？**

虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到 ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于 LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的 ACK报文。

### 序号和确认号
- MSS(最大报文段长度)：通常由最初确定的由本地发送主机发送的最大链路层帧长度(即MTU)来设置。设置该MSS要保证一个TCP报文段加上TCP/IP首部长度（通常40字节）将适合单个链路层帧。以太网和PPP链路层洗衣都具有1500字节的MTU，所以MSS典型值为1460字节。

TCP把数据看成一个无结构的、有序的字节流。**一个报文段的序号**因此是该报文段首字节的字节流编号。假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流，假定数据流包含500000字节文件，其MSS为1000字节，数据流首字节编号是0。则如下图所示：
![序号](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/%E5%BA%8F%E5%8F%B7.png) 

**主机A填充进报文段的确认号是主机A希望从主机B收到的下一个字节的序号**。

- 假设主机A已经收到来自主机B的编号为0~535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及以后的所有字节。所以主机A会在它发往主机B的报文段的确认号字段中填上536。
- 假设收到0-535字节后，又收到可900-1000报文段，还没有收到536-899的报文段，主机A为了重新构建主机B的数据流，仍在等待536-899的字节，所以A到B的另一个报文段将在确认号字段中包含536。所以TCP被称为是提供**累积确认**

另外，对于第二种情况，**接收方保留失序的字节，并等待缺少的字节以填补该间隔，对失序数据进行重新排序，然后才交给应用层**

### 超时重传机制
如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？

首先，发送方没有介绍到响应的ACK报文原因可能有两点：

- 数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。
- 接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。

简单理解就是**发送方在发送完数据后启动一个定时器**，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。
- 如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。
- 如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。

### TCP流量控制
一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后，它就将数据放入接收缓存。相关联的应用进程就会从该缓存中读取数据。如果某应用程序读取数据时相对缓慢就，或者说由于其他任务过段时间再来读取，而发送方发送的太多、太快，就会使该连接的接收缓存溢出。

TCP通过让发送方维护一个称为**接收窗口**的变量来进行流量控制。实际上，窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的**窗口字段**告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

假设主机A通过一条TCP连接向主机B发送一个大文件，主机B为该连接分配了一个接收缓存，并且主机B不时的从缓存中读取数据，定义以下变量：  

- RcvBuffer ： B的接收缓存大小
- LastByteRead： B的应用程序从缓存中读出的数据流的最后一个字节编号
- LastByteRcvd：从网络中到达并且已经放入B接收缓存中的数据流的最后一个字节的编号。  
由于TCP不允许内存溢出，所以：LastByteRcvd-LastByteRead<=RcvBuffer
接收窗口用rwnd表示则缓存可用空间：rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]  
主机B将rwnd的值放入发送给A的报文段中的窗口字段，通知A还有多少可用空间。
对于A需要跟踪两个变量：LastByteSent和LastByteAcked，这两个变量的意义很明显，而LastByteSent-LastByteAcked就是主机A发送到连接中但未被确认的数据量。只需要将未确认的数据量控制在rwnd以内，就可以保证不会使B的接收缓存溢出。
即：**LastByteSent-LastByteAcked<=rwnd**
### TCP拥塞控制
如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。
这一点和流量控制很像，但是出发点不同。**拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。而流量控制不同，流量控制指对点对点通信量的控制**
![TCP拥塞控制](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg)

拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。

发送方需要维护一个叫做**拥塞窗口**（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。
为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![拥塞算法](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95.jpghttps://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95.jpg)

#### 慢开始
**发送的最初执行慢开始，令 cwnd = 1**，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...
#### 拥塞避免
注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。**设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1**。


**如果出现了超时，则令 ssthresh = cwnd / 2，即把慢开始门限设置为出现拥塞时的发送窗口大小的一半，然后重新执行慢开始**。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（**其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理**），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。

#### 快速重传
在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

**在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段**。例如收到三个 M2，则 M3 丢失，立即重传 M3。
![快速重传](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/img/%E5%BF%AB%E9%87%8D%E4%BC%A0.png)
#### 快恢复
快恢复算法，有以下两个要点:

- **当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半**。但是接下去并不执行慢开始算法。
- **考虑到如果网络出现拥塞的话就不会收到好几个重复的确认**，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是**将cwnd设置为ssthresh的大小，然后执行拥塞避免算法**。

如上面这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。