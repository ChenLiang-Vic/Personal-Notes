<!-- TOC -->

- [文件系统基础](#文件系统基础)
    - [文件逻辑结构](#文件逻辑结构)
    - [文件目录结构](#文件目录结构)
    - [文件共享](#文件共享)
    - [文件保护](#文件保护)
- [文件系统实现](#文件系统实现)
    - [文件系统目录实现](#文件系统目录实现)
    - [文件系统文件实现](#文件系统文件实现)
        - [文件分配方式](#文件分配方式)
        - [文件空间管理](#文件空间管理)
- [磁盘组织与管理](#磁盘组织与管理)
    - [磁盘结构](#磁盘结构)
    - [磁盘调度算法](#磁盘调度算法)
        - [先来先服务(FCFS)算法](#先来先服务fcfs算法)
        - [最短寻找时间优先(SSTF)算法](#最短寻找时间优先sstf算法)
        - [扫描(SCAN)算法（又称电梯算法）](#扫描scan算法又称电梯算法)
        - [循环扫描(Circulair SCAN, C-SCAN)算法](#循环扫描circulair-scan-c-scan算法)

<!-- /TOC -->
# 文件系统基础
## 文件逻辑结构
文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从实现观点出发，又称为文件的存储结构，是指文件在外存上的存储组织形式。

按逻辑结构，文件有无结构文件和有结构文件两种类型：无结构文件和有结构文件。

无结构文件是最简单的文件组织形式。无结构文件将数据按顺序组织成记录并积累保存。由于无结构文件没有结构，因而对记录的访问只能通过穷举搜索的方式，故这种文件形式对大多数应用不适用。但字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，那些对基本信息单位操作不多的文件较适于釆用字符流的无结构方式，如源程序文件、目标代码文件等。

有结构文件按记录的组织形式可以分为：
<font size=4>**顺序文件**</font>
文件中的记录一个接一个地顺序排列，记录可以是定长的或变长的，可以顺序存储或以链表形式存储，在访问时需要顺序搜索文件。顺序文件有以下两种结构：

第一种是串结构，记录之间的顺序与关键字无关。
第二种是顺序结构，指文件中的所有记录按关键字顺序排列。

<font size=4>**索引文件**</font>
变长记录文件只能顺序查找，系统开销较大。为此可以建立一张索引表以加快检索速度，索引表本身是定长记录的顺序文件。在记录很多或是访问要求高的文件中，需要引入索引以提供有效的访问。实际中，通过索引可以成百上千倍地提高访问速度。

<font size=4>**索引顺序文件**</font>

索引顺序文件是顺序和索引两种组织形式的结合。索引顺序文件将顺序文件中的所有记录分为若干个组，为顺序文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。

索引文件和索引顺序文件都提高了存取的速度，但因为配置索引表而增加了存储空间。

<font size=4>**直接文件或散列文件**</font>
给定记录的键值或通过Hash函数转换的键值直接决定记录的物理地址。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。

散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同。

## 文件目录结构
**文件控制块FCB**
同进程管理一样，为实现目录管理，操作系统中引入了文件控制块的数据结构来存放控制文件需要的各种信息，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。为了创建一个新文件，系统将分配一个FCB并存放在文件目录中，成为目录项。

**索引结点**
在检索目录文件的过程中，只用到了文件名，仅当找到一个目录项（查找文件名与目录项中文件名匹配）时，才需要从该目录项中读出该文件的物理地址。也就是说，在检索目录时，文件的其他描述信息不会用到，也不需调入内存。因此，有的系统（如UNIX）釆用了文件名和文件描述信息分开的方法，文件描述信息单独形成一个称为索引结点的数据结构，简称为 i 结点。在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。

<font size=4>**单级目录结构**</font>

在整个文件系统中只建立一张目录表，所有文件均在这个目录结构中。

![单级目录结构](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

单级目录结构实现了 “按名存取”，但是存在查找速度慢、文件不允许重名、不便于文件共享等缺点，而且对于多用户的操作系统显然是不适用的。
<font size=4>**两级目录结构**</font>

单级目录很容易造成文件名称的混淆，可以考虑釆用两级方案，将文件目录分成主文件目录(Master File Directory, MFD)和用户文件目录（User File Directory, UFD)。两级文件目录项记录用户名及相应用户文件目录所在的存储位置。用户文件目录项记录该用户文件的FCB信息。

![两级目录结构](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%A4%E7%BA%A7%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

两级目录结构可以解决多用户之间的文件重名问题，文件系统可以在目录上实现访问限制。但是两级目录结构缺乏灵活性，不能对文件分类。

<font size=4>**多级目录结构(树形目录结构)**</font>

用户要访问某个文件时用文件的路径名标识文件，文件路径名是个字符串，由从根目录出发到所找文件的通路上的所有目录名与数据文件名用分隔符链接起来而成。

通常，每个用户都有各自的“当前目录”,登录后自动进入该用户的“当前目录”。操作系统提供一条专门的系统调用，供用户随时改变“当前目录”。例如，UNIX系统中， “/etc/passwd”文件就包含有用户登录时默认的“当前目录”，可用cd命令改变“当前目录”

![多机目录结构](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%A4%9A%E7%BA%A7%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，在树形目录中查找一个文件，需要按路径名逐级访问中间结点，这就增加了磁盘访问次数，无疑将影响查询速度。
<font size=4>**无环图目录结构**</font>

树形目录结构可便于实现文件分类，但不便于实现文件共享，为此在树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个有向无环图。引入无环图目录结构是为了实现文件共享

![无环图目录结构](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

共享文件（或目录）不同于文件拷贝（副本）。如果有两个文件拷贝，每个程序员看到的是拷贝而不是原件；但如果一个文件被修改，那么另一个程序员的拷贝不会有改变。对于共享文件，只存在一个真正文件，任何改变都会为其他用户所见。

无环图目录结构方便实现了文件的共享,但使得系统的管理变得更加复杂。
## 文件共享
文件共享使多个用户（进程）共享同一份文件，系统中只需保留该文件的一份副本。

现代常用的两种文件共享方法有：
回到顶部
<font size=4>**基于索引结点的共享方式（硬链接）**</font>

在树形结构的目录中，当有两个或多个用户要共享一个子目录或文件时，必须将共享文件或子目录链接到两个或多个用户的目录中，才能方便地找到该文件

![硬链接](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A1%AC%E9%93%BE%E6%8E%A5.png)

当用户A创建一个新文件时，它便是该文件的所有者，此时将count置为1。当有用户 B要共享此文件时，在用户B的目录中增加一个目录项，并设置一指针指向该文件的索引结点。此时，文件主仍然是用户A，count=2。如果用户A不再需要此文件，不能将文件直接删除。因为，若删除了该文件，也必然删除了该文件的索引结点，这样便会便用户B的指针悬空，而用户B则可能正在此文件上执行写操作，此时用户B会无法访问到文件。因此用户A不能删除此文件，只是将该文件的count减1，然后删除自己目录中的相应目录项。用户B仍可以使用该文件。当COunt=0时，表示没有用户使用该文件，系统将负责删除该文件。

<font size=4>**利用符号链实现文件共享（软链接）**</font>

为使用户B能共享用户A的一个文件F,可以由系统创建一个LINK类型的新文件，也取名为F，并将文件F写入用户B的目录中，以实现用户B的目录与文件F的链接。在新文件中只包含被链接文件F的路径名。这样的链接方法被称为符号链接。

![软链接](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BD%AF%E9%93%BE%E6%8E%A5.png)

在利用符号链方式实现文件共享时，只有文件的拥有者才拥有指向其索引结点的指针。而共享该文件的其他用户则只有该文件的路径名，并不拥有指向其索引结点的指针。这样，也就不会发生在文件主删除一共享文件后留下一悬空指针的情况。当文件的拥有者把一个共享文件删除后，其他用户通过符号链去访问它时，会出现访问失败，于是将符号链删除，此时不会产生任何影响。

## 文件保护
为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。

文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令保护和加密保护是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式。
# 文件系统实现

现代操作系统有多种文件系统类型（如FAT32、NTFS、 ext2、ext3、ext4等），因此文件系统的层次结构也不尽相同。下图是一种合理的层次结构。

![文件系统层次结构](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)

## 文件系统目录实现
在读文件前，必须先打开文件。打开文件时，操作系统利用路径名找到相应目录项，目录项中提供了查找文件磁盘块所需要的信息。
目录实现的基本方法有线性列表和哈希表两种。

<font size=4>**线性表**</font>

最简单的目录实现方法是使用存储文件名和数据块指针的线性表。

无序线性表：查找文件较慢，新建文件较快
有序线性表：查找文件较快，新建文件较慢

<font size=4>**哈希表**</font>

哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。

这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免冲突。最大的困难是哈希表长度固定以及哈希函数对表长的依赖性。

## 文件系统文件实现
文件的实现就是研究文件的物理结构，即文件数据在物理存储设备上是如何分布和组织的。同一个问题有两个方面的回答：一是文件的分配方式，讲的是对磁盘非空闲块的管理；二是文件存储空间管理，讲的是对磁盘空闲块的管理。

### 文件分配方式
文件分配对应于文件的物理结构，是指**如何为文件分配磁盘块**。常用的磁盘空间分配方法有三种：连续分配、链接分配和索引分配。

<font size=4>**连续分配**</font>
连续分配方法要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序。这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。

连续分配支持顺序访问和直接访问。其优点是实现简单、存取速度快。

缺点在于，文件长度不宜动态增加，因为一个文件末尾后的盘块可能已经分配给其他文件，一旦需要增加，就需要大量移动盘块。此外，反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似)，并且很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。
<font size=4>**链接分配**</font>

每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何 地方，除最后一个盘块外，每一个盘块都有指向下一个盘块的指针，这些指针对用户是透明的。目录包括文件第一块的指针和最后一块的指针

由于链接分配是釆取离散分配的方式，消除了外部碎片，故而显著地提高了磁盘空间的利用率；又因为是根据文件的当前需求，为它分配必需的盘块，当文件动态增长时，可以动态地再为它分配盘块，故而无需事先知道文件的大小。此外，对文件的增、删、改也非常方便。

隐式链接分配的缺点在于无法直接访问盘块，只能通过指针顺序访问文件，以及盘块指 针消耗了一定的存储空间
<font size=4>**索引分配**</font>
索引分配解决了链接分配无法直接访问的问题，它把每个文件的所有的盘块号都集中放在一起构成索引块（表）。每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第i个条目指向文件的 第i个块。目录条目包括索引块的地址。要读第i块，通过索引块的第i个条目的指针来查 找和读入所需的块。

索引分配支持直接访问，且没有外部碎片问题。其缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的 问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件，可以使用链接、多层索引、混合索引来解决这个问题。

三种分配方式对比
![文件分配方式对比](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.png)

### 文件空间管理
文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、 分配与回收等问题。

文件的空间管理主要由空闲表法、空闲链表法、位示图法、成组链接法等。
# 磁盘组织与管理

## 磁盘结构
- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

![磁盘结构](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png)

## 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间
其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

### 先来先服务(FCFS)算法
FCFS(First Come First Served)算法根据进程请求访问磁盘的先后顺序进行调度，这是一种最简单的调度算法。

例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道，釆用FCFS算法磁头的运动过程如图4-25所示。磁头共移动了 (45+3+19+21+72+70+10+112+146)=498 个磁道，平均寻找长度=498/9=55.3

![FCFS](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/FCFS.png)

该算法的优点是具有公平性。如果只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能；但如果有大量进程竞争使用磁盘，那么这种算法在性能上往往接近于随机调度。所以，实际磁盘调度中考虑一些更为复杂的调度算法。

### 最短寻找时间优先(SSTF)算法
SSTF(Shortest  Seek  Time  First)算法选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以使每次的寻找时间最短。

例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道。磁头共移动了 (10+32+3+16+1+20+132+10+24)=248 个磁道，平均寻找长度=248/9=27.5。

![SSTF](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/SSTF.png)

总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS算法更好的性能。这种算法会产生“饥饿”现象。

### 扫描(SCAN)算法（又称电梯算法）

SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对最近扫描过的区域不公平，因此，它在访问局部性方面不如FCFS算法和 SSTF算法好。

例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100 磁道。釆用SCAN算法时，不但要知道磁头的当前位置，还要知道磁头的移动方向，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如图4-27所示。磁头共移动了(50+10+24+94+32+3+16+1+20)=250 个磁道，平均寻找长度=250/9=27.8

![SCAN](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/SCAN.png)

### 循环扫描(Circulair SCAN, C-SCAN)算法
由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题.釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。

例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道。釆用C-SCAN算法时，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如图4-28所示。磁头共移动了(50+10+24+166+20+1+16+3+32)=322个磁道，平均寻道长度=322/9=35.8

![CSCAN](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/C-SCAN.png)

四种算法的对比
![算法对比](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png)