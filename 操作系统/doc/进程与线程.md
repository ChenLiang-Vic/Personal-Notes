<!-- TOC -->

- [进程与线程](#进程与线程)
    - [1. 进程](#1-进程)
    - [2. 线程](#2-线程)
    - [3. 区别](#3-区别)
- [进程状态的切换](#进程状态的切换)
- [进程调度算法](#进程调度算法)
    - [1. 批处理系统](#1-批处理系统)
        - [1.1 先来先服务（FCFS)](#11-先来先服务-first-come-first-serverdfcfs)
        - [1.2 短作业优先（SJF）](#12-短作业优先-shortest-job-firstsjf)
        - [1.3 最短剩余时间优先 （SRTN）](#13-最短剩余时间优先-shortest-remaining-time-nextsrtn)
    - [2. 分时系统](#2-分时系统)
        - [2.1 时间片轮转](#21-时间片轮转)
        - [2.2 优先级调度](#22-优先级调度)
        - [2.3 多级反馈队列](#23-多级反馈队列)
    - [3. 实时系统](#3-实时系统)
- [进程同步](#进程同步)
    - [1. 临界区](#1-临界区)
    - [2. 同步与互斥](#2-同步与互斥)
    - [3. 信号量](#3-信号量)
    - [4. 管程](#4-管程)
- [经典同步问题](#经典同步问题)
    - [1. 读者-写者问题](#1-读者-写者问题)
    - [2. 哲学家进餐问题](#2-哲学家进餐问题)
    - [3. 吸烟者问题](#3-吸烟者问题)
- [进程通信](#进程通信)
- [死锁](#死锁)
    - [鸵鸟策略](#鸵鸟策略)
    - [死锁预防](#死锁预防)
    - [死锁避免](#死锁避免)
        - [1.安全状态](#1安全状态)
        - [2.银行家算法](#2银行家算法)
    - [死锁的检测与解除](#死锁的检测与解除)


# 进程与线程

## 1. 进程

进程是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。注意：PCB是进程存在的唯一标志

下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

![进程](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B.png)

## 2. 线程

线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

线程的实现可以分为两类：用户级线程和内核级线程。

在用户级线程中，有关线程管理工作由应用程序完成，内核意识不到线程的存在，如下图a所示。在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口，如下图b所示。当然，有些系统中使用组合方式的多线程实现，如图c所示。

![线程](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%BA%BF%E7%A8%8B.png)

## 3. 区别

Ⅰ 拥有资源

进程是拥有资源的基本单位，而线程不拥有资源（也有一点儿必不可少的资源），但线程可以访问其隶属进程的系统资源。

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，则会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以通过直接读写同一进程中的数据进行通信

# 进程状态的切换

![进程之间状态切换](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png)

以下三种状态为进程基本状态：
- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

# 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

## 1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

### 1.1 先来先服务 first-come first-serverd（FCFS)

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

### 1.2 短作业优先 shortest job first（SJF）

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

### 1.3 最短剩余时间优先 shortest remaining time next（SRTN）

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

## 2. 分时系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

### 2.1 时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：
- 若时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为FCFS算法。
- 若时间片很小，则处理机将在进程间过于频繁切换，增加处理机开销，真正用于运行用户进程的时间将减少。



### 2.2 优先级调度

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

### 2.3 多级反馈队列

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

首先，设置多个就绪队列，并为每个队列赋予不同的优先级，第1级队列的优先级最高，依次递减。

然后，赋予每个队列中进程执行时间片的大小各不相同。优先级越高的队列中，每个进程运行时间片越小。即第1级队列中时间片比第2级队列中的时间片小，依次类推、

当一个新进程进入内存后，首先将它放在第1级队列末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如果能在该时间片内完成，即可撤离系统，否则进入第2级队列末尾，依次类推。

仅当第1级队列为空时，调度程序才调度第2级对立中的进程执行。若处理机正在执行第i级队列中的某个进程，这时又有新进程进入优先级较高的队列（1~i-1级队列）时，则新进程抢占正在运行进程的处理机，把正在运行的进程放回i级队列末尾，把处理机分配给新到的更高优先级的进程。

![多级反馈队列](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png)

## 3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

主要是优先级调度算法。
一般优先级的设置原则：
- I/O繁忙型作业要优于计算繁忙型作业
- 系统进程的优先级高于用户进程优先级
- 作业优先权与长作业、短作业或系统资源的要求的多少没有必然联系
- 动态优先权中，随着进程执行时间的增加其优先权随之降低，随着作业等待时间的增加其优先权相应上升

# 进程同步

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：**控制多个进程按一定顺序执行**；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

## 1. 临界区

一次仅允许一个进程使用的资源称为**临界资源**，如打印机等，此外还有许多变量数据等都可以被若干进程共享，也属于临界资源。对临界资源进行访问的那段代码称为**临界区**。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```html
do{
    entry section;  //进入区  检查可进入后设置正在访问临界区标志
    critical section;  //临界区
    exit section;  //退出区   将正在访问临界区的标志清除
    remainder section;  //剩余区  代码中的剩余部分
} while(true)
```

## 2. 同步与互斥

- 同步：多个进程按一定顺序执行；
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

## 3. 信号量

信号量机制用来解决互斥与同步问题。信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

具体运作方式如下：

1. 初始化，给与它一个非负数的整数值。
2.  **P（wait（））操作**  : 信号量S的值将被减少。企图进入临界区块的进程，需要先运行P。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。
-  **V（signal（））操作** ：信号量S的值会被增加。结束离开临界区块的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区块。

P 和 V 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

**信号量实现同步**
```html
semaphore S = 0;  //初始化信号量
P1(){
    x;  //语句x
    V(S);  //告诉进程P2,语句x已经完成
}

P2(){
    ...
    P(S);  //检查x是否运行完成
    y;  //检查无误，执行y语句
}
```

**信号量实现互斥**
```html
semaphore S = 0;  //初始化信号量
P1(){
    P(S);  //准备访问临界资源加锁
    进程P1的临界区;
    V(S);  //访问结束，解锁
}

P2(){
    ...
    P(S);  //准备访问临界资源加锁
    进程P2的临界区;
    V(S);  //访问结束，解锁
}
```

如果信号量的取值只能为 0 或者 1，那么就成为了  **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

```c
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区代码
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区代码
    up(&mutex);
}
```

总结：在同步问题中，若某个行为要用到某种资源，则在这个行为前面P这种资源一下；若某个行为会释放某种资源，则在这个行为后面V这种资源一下。 互斥问题中，P、V操作要紧夹使用互斥资源的那个行为，中间不能有其他冗余代码。

<font size=4>  **使用信号量实现生产者-消费者问题**  </font> </br>

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 P(mutex) 再执行 P(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 P(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 V(empty) 操作，empty 永远都为 0，导致生产者永远等待，不会释放锁，消费者因此也会永远等待下去。

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        P(&empty);
        P(&mutex);
        insert_item(item);
        V(&mutex);
        V(&full);
    }
}

void consumer() {
    while(TRUE) {
        P(&full);
        P(&mutex);
        int item = remove_item();
        consume_item(item);
        V(&mutex);
        V(&empty);
    }
}
```

## 4. 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```pascal
monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
```

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了  **条件变量**  以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

<font size=3> **使用管程实现生产者-消费者问题** </font><br>

```pascal
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

# 经典同步问题

生产者和消费者问题前面已经讨论过了。

## 1. 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，保护更新count变量时的互斥；一个互斥量 data_mutex 用于保证读者和写者的互斥访问。


**读优先算法**
```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        P(&count_mutex);
        if(count == 0) P(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        count++;
        V(&count_mutex);
        read();
        P(&count_mutex);
        count--;
        if(count == 0) V(&data_mutex);  //最后一个读者读完后释放数据资源，允许写进程写
        V(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        P(&data_mutex); //互斥访问共享文件
        write();  //写入
        V(&data_mutex);  //释放共享文件
    }
}
```
上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有一个读进程活跃，随后而来的进程都将被允许访问文件。

若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应该禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行。

为此，增加一个信号量w用来控制写的优先级，如下程序所示。

**写优先算法**

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
semaphore w = 1;  //增加一个互斥量w用于实现“写优先”
int count = 0;

void reader() {
    while(TRUE) {
        P(w);  //无写进程请求时进入
        P(&count_mutex);
        if(count == 0) P(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        count++;
        V(&count_mutex);
        V(w);  //恢复对共享文件的访问
        read();
        P(&count_mutex);
        count--;
        if(count == 0) V(&data_mutex);  //最后一个读者读完后释放数据资源，允许写进程写
        V(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        P(w);  //在无写进程请求时进入
        P(&data_mutex); //互斥访问共享文件
        write();  //写入
        V(&data_mutex);  //释放共享文件
        V(w;  //恢复对共享文件的访问
    }
}
```

## 2. 哲学家进餐问题

![哲学家问题](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90.png)

五个哲学家围着一张圆桌，每两名哲学家之间的桌上摆一根筷子，如上图所示。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。若筷子已在他人手中，则需要等待。

下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。

```c
semaphore chopstick[5] = {1,1,1,1,1};

void philosopher(int i) {
    while(TRUE) {
        P(chopstick[i]);  //取左边筷子
        P(chopstick[(i+1)%5]);  //取右边筷子
        eat；
        V(chopstick[i]);  //放左边筷子
        V(chopstick[(i+1)%5]);  //放右边筷子
        think；
    }
}
```

为了防止死锁的发生，可以设置一些规则：

当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子

```c
semaphore chopstick[5] = {1,1,1,1,1};
semaphore mutex = 1；  //设置取筷子信号量

void philosopher(int i) {
    while(TRUE) {
        P(mutex);
        P(chopstick[i]);  //取左边筷子
        P(chopstick[(i+1)%5]);  //取右边筷子
        V(mutex);
        eat；
        V(chopstick[i]);  //放左边筷子
        V(chopstick[(i+1)%5]);  //放右边筷子
        think；
    }
}
```

## 3. 吸烟者问题
假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停的卷烟并抽掉它，但要卷起一支烟，需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者无限地提供三种材料，供应者每次讲两种材料放到桌子上，拥有剩下那种材料的抽烟者将卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者会将另外两种材料放到桌上，如此重复(让三个抽烟者轮流的抽烟)


```c
semaphore offer1=0;  //定义信号量对应烟草和纸组合的资源
semaphore offer2=0;  //定义信号量对应烟草和胶水组合的资源
semaphore offer3=0;  //定义信号量对应胶水和纸组合的资源
semaphore finish=0;  //定义信号量表示抽烟是否完成
int random;  

void process Provider(){
    while(TRUE){
        random = 任意随机数；
        random = random % 3;
        if(random==0)
            V(offer1);  //提供资源1
        else if(random==1)
            V(offer2);  //提供资源2
        else 
            V(offer3);  //提供资源3   

        P(finish);
    }
}


void process Smoker1(){
    while(TRUE){
        P(offer3);
        V(finish);
    }
}

void process Smoker2(){
    while(TRUE){
        P(offer2);
        V(finish);
    }
}


void process Smoker3(){
    while(TRUE){
        P(offer1);
        V(finish);
    }
}


```


# 进程通信
进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类：

1. 共享存储

在通信的进程之间存在一块可以直接访问的共享空间，通过对这片共享空间进行读/写操作实现进程之间的信息交换。在对共享空间进行读/写操作时，需要使用同步互斥工具对共享空间读/写进行控制

2. 消息传递

在消息传递系统中，进程间的数据交换是以格式化的消息为单位的。分为直接通信方式和间接通信方式两种。

3. 管道通信

管道是指用于连接一个读进程和一个写进程以实现他们之间的通信的一个共享文件，又名pipe文件。为了协调双方的通信，管道机制必须提供三方面的协调能力：互斥、同步和确定对方的存在。

管道通信具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。


# 死锁

多个进程因为竞争资源而形成的互相等待的现象，此时若无外力作用，这些进程都将无法向前推进。

**必要条件**

- 互斥条件：即一段时间内某资源仅为一个进程所占有。此时若有其他进程请求资源，则请求进程只能等待。
- 不剥夺条件：进程所获得的资源在未使用完之前，不能被其他进程抢夺。即该资源只能进程主动释放。
- 请求并保持条件： 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源被其他进程占有。
- 循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个资源所请求。

注意为什么循环等待只是死锁的必要条件：

![循环等待](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85.png)

Pk不属于循环等待链P1--Pn

**死锁处理方法**
主要有以下四种方法：
- 鸵鸟策略
- 死锁预防
- 死锁避免
- 死锁的检测与解除

## 鸵鸟策略
把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

## 死锁预防
防止死锁的繁盛只需要破坏死锁产生的4个必要条件之一即可。

1. 破坏互斥条件    允许系统资源都能共享使用
2. 破坏不剥夺条件  当一个已经保持了某些不可剥夺资源的进程请求新的资源而得不到满足是，它必须释放已经保持的所有资源。
3. 破坏请求并保持条件  采用预先分配的方法，即进程在运行前一次申请完它所需要的全部资源，在他的资源未满足前，不把他投入运行。
4. 破坏循环等待条件  采用顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完。

## 死锁避免
在程序运行中（资源动态分配过程中）防止系统进入不安全状态，以避免发生死锁。

### 1.安全状态

安全状态指系统能够按照某种进程推进顺序为每个进程P分配其所需要的资源，直至满足各个进程对资源的最大需求，使每个进程都可顺序完成。此时称P1 P2 P3...为安全序列。若无法找到一个安全序列，则称系统处于不安全状态。

![安全状态](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81.png)

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 一旦图c中将5分配1个资源给A 则此时系统处于不安全状态，因为此时无法再找到一个安全序列。

### 2.银行家算法

银行家算法是最著名的死锁避免算法，其思想是：一个小城镇的银行家（操作系统），他向一群客户（进程）分别承诺了一定的贷款额度（资源数），算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

对于单资源来说，很好判断。

![单资源银行家算法](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8D%95%E8%B5%84%E6%BA%90%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.png)

对于多资源来说，核心是找到MAX矩阵，Allocation矩阵和Need阵中的2个从而，求出另一个，之后使用未分配资源向量和Need阵比较。

![多资源银行家算法](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%A4%9A%E8%B5%84%E6%BA%90%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.png)

上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

检查一个状态是否安全的算法如下：

查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
重复以上两步，直到所有进程都标记为终止，则状态时安全的。
如果一个状态不是安全的，需要拒绝进入这个状态。

## 死锁的检测与解除

前面介绍的死锁预防和避免算法，都是在为进程分配资源时事假限制条件或进行检测，若系统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除手段

**死锁检测**

![死锁检测](https://github.com/ChenLiang-Vic/Personal-Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B.png)

上图中，有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量
进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

1. 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

2. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。

3. 如果没有这样一个进程，算法终止。

**死锁解除**
- 资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便让其他进程继续推进
- 撤销进程法：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源
- 进程回退法：让一个或多个进程回退到足以回避死锁的地步。