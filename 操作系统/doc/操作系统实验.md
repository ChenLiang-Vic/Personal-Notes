
# 1. 操作系统引导
## 基础知识
因为计算机的工作本质就是**取指执行**，所以我们刚打开电源时，我们需要关注**指针IP**和其**指向的内容**

### x86计算机中开始加电过程
1. X86计算机刚开始时CPU处于实模式
2. 开机时，段寄存器CS=0xFFFF  段内偏移IP=0x0000（地址 = CS<<4+IP） 计算后刚好等于BIOS地址0xFFFF0
3. 寻址0xFFFF0(ROM BIOS映射区)
4. 检查RAM，键盘，显示器，软硬磁盘
5. 将磁盘0磁道0扇区(**操作系统引导扇区**)读入0x7c00处（1个扇区512字节）
6. 设置CS=0x07c0，IP = 0x0000  计算后刚好为0x7c00处  

### 0x7c00处存放的代码bootsect.s
从上面可以了解到0x7c00处就是从磁盘引导扇区读入的512个字节，即**bootsect.s**  

### bootsect.s源代码

1. 下面的代码用来将0x07c0:0x0000处的512字节即bootsect.s移动到0x9000:0x0000处，腾出空间  
![bootsect.s](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/bootsect.png)

2. 接下来使用13号中断读取setup的4个扇区  
![bootsect2.s](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/bootsect2.png)

3. 读入setup后使用10号中断显示字符（即我们平时开机时显示的黑屏的操作系统logo)  
![bootsect3.s](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/bootsect3.png)

4. 之后继续使用13号中断读取操作系统剩余部分   bootsect结束，进入setup部分  
![bootsect4.s](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/bootsect4.png)

### setup.s源代码

setup.s主要做了两件事：
1. 使用15号中断读取电脑硬件内存大小，并存到0x90002处
2. 将操作系统部分移动到0处

![setup1.s]()

之后，setup将计算机从**实模式**切换到**保护模式**。

![setup2.s]()
cs和ip都是16位寄存器，按照原来的寻址方式cs左移4位+ip最多为20位即1M，远远不能满足需求，所以要借用cr0寄存器（硬件修改）启用32位寻址方式。

保护模式下的地址翻译
![setup3.s]()

### System部分


## 实验1.操作系统的引导
### 1.改写bootsect.s
主要完成如下功能：bootsect.s能在屏幕上打印一段提示信息“XXX is booting...”，其中XXX是你给自己的操作系统起的名字，例如LZJos、Sunix等

从之前的bootsect.s的源码分析中可以知道，只需要修改**Loading System...** 处和**控制其字符显示长度的cx处**即可,实验结果如下图所示：  

![bootsect实验结果](https://github.com/ChenLiang-Vic/Personal-notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/bootsect%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C.png)

### 2.改写setup.s
主要完成如下功能：
- bootsect.s能完成setup.s的载入，并跳转到setup.s开始地址执行。而setup.s向屏幕输出一行"Now we are in SETUP"。  
- setup.s能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。 
- setup.s不再加载Linux内核，保持上述信息显示在屏幕上即可。  



# 实验2. 系统调用