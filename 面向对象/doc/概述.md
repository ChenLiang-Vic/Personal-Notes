<!-- TOC -->

- [概念](#概念)
- [设计原则](#设计原则)
    - [S.O.L.I.D](#solid)
    - [其他常见原则](#其他常见原则)
- [Java中23种设计模式](#java中23种设计模式)

<!-- /TOC -->
# 概念
GOF23种设计模式

GOF(“四人帮”，又称Gang of Four，即Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides)

设计模式：**是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结**。

使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。

# 设计原则
## S.O.L.I.D

|简写|全拼|中文翻译|
|----|----|----|
|SRP| The Single Responsibility Principle|单一责任原则
|OCP|The Open Closed Principle|开放封闭原则
|LSP|The Liskov Substitution Principle|里氏替换原则
|ISP|The Interface Segregation Principle|接口分离原则
|DIP|The Dependency Inversion Principle|依赖倒置原则

<font size = 4>**1.单一责任原则**</font>
> 修改一个类的原因应该只有一个。

换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。
<font size = 4>**2. 开放封闭原则**</font>

> 类应该对扩展开放，对修改关闭。

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。

<font size = 4>**3. 里氏替换原则**</font>

> 子类对象必须能够替换掉所有父类对象。

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

<font size = 4>**4. 接口分离原则**</font>

> 不应该强迫客户依赖于它们不用的方法。

因此使用多个专门的接口比使用单一的总接口要好。

<font size = 4>**5. 依赖倒置原则**</font>

> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

- 任何变量都不应该持有一个指向具体类的指针或者引用；
- 任何类都不应该从具体类派生；
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。
## 其他常见原则
除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。

|简写|全拼|中文翻译|
|----|----|----|
|LOD|The Law of Demeter|迪米特法则
CRP|The Composite Reuse Principle|合成复用原则
CCP|The Common Closure Principle|共同封闭原则
SAP|The Stable Abstractions Principle|稳定抽象原则
SDP|The Stable Dependencies Principle|稳定依赖原则

<font size = 4>**1. 迪米特法则**</font>
迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

<font size = 4>**2. 合成复用原则**</font>

尽量使用对象组合，而不是通过继承来达到复用的目的。

<font size = 4>**3. 共同封闭原则**</font>

一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。

<font size = 4>**4. 稳定抽象原则**</font>

最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。

<font size = 4>**5. 稳定依赖原则**</font>

包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。


# Java中23种设计模式
创建型（5种）

| 设计模式 | 核心作用 |
| ------- | ------- |
|单例模式|保证一个类仅有一个实例，并提供一个访问它的全局访问点|
|原型模式|用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象|
|建造者模式|将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示|
|工厂模式|定义一个用于创建对象的接口，让子类决定将哪一个类实例化。FactoryMethod使一个类的实例化延迟到其子类|
|抽象工厂模式|提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类|

结构型(7种)

| 设计模式 | 核心作用 |
| ---------- | ---------- |
| 桥接模式 |将抽象部分与它的实现部分分离，使它们都可以独立地变化|
|外观模式|为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用|
|组合模式|将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性|
|装饰模式|动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活|
|适配器模式|将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作|
|代理模式|为其他对象提供一个代理以控制对这个对象的访问|
|享元模式|运用共享技术有效地支持大量细粒度的对象|


行为型（11种）

| 设计模式 | 核心作用 |
| ------- | ------- |
|迭代器模式|提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示|
|解析器模式|给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子|
|观察者模式|定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新|
|中介者模式|用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互|
|访问者模式|表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作|
|备忘录模式|在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态 |
|状态模式|允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。|
|策略模式|定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户|
|模板方法模式|定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。该方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。|
|命令模式 | 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 |
|职责链模式 | 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它 |